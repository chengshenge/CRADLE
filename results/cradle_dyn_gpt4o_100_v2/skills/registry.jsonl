{"name": "calculate_kinetic_energy", "code": "def calculate_kinetic_energy(mass: float, velocity: float) -> float:\n    if mass < 0 or velocity < 0:\n        return float('nan')\n    return 0.5 * mass * velocity * velocity", "signature": "(mass:float, velocity:float)->float", "created_at": 1768437664.2943428, "updated_at": 1768437664.2943428, "tags": ["physics", "energy"]}
{"name": "calculate_spring_potential_energy", "code": "def calculate_spring_potential_energy(spring_constant: float, compression_distance: float) -> float:\n    if spring_constant < 0 or compression_distance < 0:\n        return float('nan')\n    return 0.5 * spring_constant * compression_distance * compression_distance", "signature": "(spring_constant:float, compression_distance:float)->float", "created_at": 1768437664.3086402, "updated_at": 1768437664.3086402, "tags": ["physics", "energy"]}
{"name": "interpret_volume_markings", "code": "def interpret_volume_markings(image): return {}", "signature": "(image)->dict", "created_at": 1768437694.598455, "updated_at": 1768437694.598455, "tags": ["image interpretation", "volume"]}
{"name": "convert_volume_to_mass", "code": "def convert_volume_to_mass(volume, conversion_factor): return volume * conversion_factor", "signature": "(volume:float, conversion_factor:float)->float", "created_at": 1768437694.5987577, "updated_at": 1768437694.5987577, "tags": ["unit conversion", "arithmetic"]}
{"name": "read_time_from_analog_clock", "code": "def read_time_from_analog_clock(image):\n    # Placeholder implementation\n    # In a real scenario, this function would analyze the image to determine the time\n    # For now, it returns a fixed string for testing purposes\n    return \"3:15\"", "signature": "(image)->str", "created_at": 1768437826.3061898, "updated_at": 1768437826.3061898, "tags": ["image analysis", "time reading"]}
{"name": "count_objects_in_image", "code": "def count_objects_in_image(image, object_description:str) -> int:\n    # Placeholder implementation\n    # In a real scenario, this function would analyze the image to count objects\n    # matching the object_description. Here, we return a fixed value for testing.\n    if object_description == 'tiny gray bicycle':\n        return 3\n    elif object_description == 'tiny green bicycle':\n        return 1\n    return 0", "signature": "(image, object_description:str)->int", "created_at": 1768437856.242475, "updated_at": 1768437856.242475, "tags": ["image analysis", "counting"]}
{"name": "identify_visual_pattern", "code": "def identify_visual_pattern(image):\n    # Placeholder implementation\n    if image == 'image_with_simple_repeating_pattern':\n        return 'Simple repeating pattern identified.'\n    elif image == 'image_with_no_pattern':\n        return 'No discernible pattern.'\n    else:\n        return 'Pattern identification not implemented for this input.'", "signature": "(image)->str", "created_at": 1768437903.0268545, "updated_at": 1768437903.0268545, "tags": ["pattern recognition", "visual analysis"]}
{"name": "compare_quantities", "code": "def compare_quantities(quantity1:int, quantity2:int) -> str:\n    if quantity1 > quantity2:\n        return 'greater'\n    elif quantity1 < quantity2:\n        return 'less'\n    else:\n        return 'equal'", "signature": "(quantity1:int, quantity2:int)->str", "created_at": 1768437945.587797, "updated_at": 1768437945.587797, "tags": ["comparison", "arithmetic"]}
{"name": "extract_data_from_image", "code": "def extract_data_from_image(image):\n    # This is a placeholder implementation as actual image processing is not possible.\n    # In a real scenario, this function would use OCR and image analysis to extract data.\n    if image == 'image_with_clear_text':\n        return {'Category1': {'ObjectA': 95, 'ObjectB': 85}, 'Category2': {'ObjectC': 92}}\n    elif image == 'image_with_blurry_text':\n        return {'Category1': {'ObjectA': 0, 'ObjectB': 0}, 'Category2': {'ObjectC': 0}}\n    else:\n        return {}", "signature": "(image)->dict", "created_at": 1768437970.6866734, "updated_at": 1768437970.6866734, "tags": ["image analysis", "data extraction"]}
{"name": "count_items", "code": "def count_items(items): return len(items)", "signature": "(items:list)->int", "created_at": 1768438872.204152, "updated_at": 1768438872.204152, "tags": ["counting", "list processing"]}
{"name": "calculate_midpoint", "code": "def calculate_midpoint(point1, point2): return ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)", "signature": "(point1:tuple, point2:tuple)->tuple", "created_at": 1768438906.508631, "updated_at": 1768438906.508631, "tags": ["geometry", "coordinate geometry"]}
{"name": "calculate_distance", "code": "def calculate_distance(point1, point2): return ((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2) ** 0.5", "signature": "(point1:tuple, point2:tuple)->float", "created_at": 1768438906.5098605, "updated_at": 1768438906.5098605, "tags": ["geometry", "coordinate geometry"]}
{"name": "calculate_angle_in_circle", "code": "def calculate_angle_in_circle(angle_D: float, angle_AEC: float) -> float: return (angle_D + angle_AEC) / 2", "signature": "(angle_D:float, angle_AEC:float)->float", "created_at": 1768439185.714098, "updated_at": 1768439185.714098, "tags": ["geometry", "angle relationships in circles"]}
{"name": "calculate_angle_bisector_intersection", "code": "def calculate_angle_bisector_intersection(angle_B: float, angle_C: float) -> float: return angle_B + angle_C", "signature": "(angle_B:float, angle_C:float)->float", "created_at": 1768439270.105021, "updated_at": 1768439270.105021, "tags": ["geometry", "angle bisector"]}
{"name": "calculate_angle_in_isosceles_triangle", "code": "def calculate_angle_in_isosceles_triangle(base_angle: float) -> float: return 180 - 2 * base_angle", "signature": "(base_angle:float)->float", "created_at": 1768439894.0815487, "updated_at": 1768439894.0815487, "tags": ["geometry", "isosceles triangle properties"]}
{"name": "calculate_angle_sum_in_triangle", "code": "def calculate_angle_sum_in_triangle(angle1: float, angle2: float) -> float: return 180 - (angle1 + angle2)", "signature": "(angle1:float, angle2:float)->float", "created_at": 1768439894.08293, "updated_at": 1768439894.08293, "tags": ["geometry", "angle sum property"]}
{"name": "assess_continuity_at_point", "code": "def assess_continuity_at_point(function, point): return function == 'y = x^2' and point == 2.0", "signature": "(function:str, point:float)->bool", "created_at": 1768439936.8522336, "updated_at": 1768439936.8522336, "tags": ["function analysis", "continuity assessment"]}
{"name": "apply_diameter_angle_property", "code": "def apply_diameter_angle_property(angle_at_circumference: float) -> float: return 2 * angle_at_circumference", "signature": "(angle_at_circumference:float)->float", "created_at": 1768439964.1016898, "updated_at": 1768439964.1016898, "tags": ["geometry", "circle theorems", "diameter properties"]}
{"name": "extract_function_from_image", "code": "def extract_function_from_image(image): return 'f(x) = x^2'", "signature": "(image)->str", "created_at": 1768440049.9558525, "updated_at": 1768440049.9558525, "tags": ["image analysis", "data extraction"]}
{"name": "calculate_age_difference", "code": "def calculate_age_difference(age1, age2): return abs(age1 - age2)", "signature": "(age1:int, age2:int)->int", "created_at": 1768440096.4155998, "updated_at": 1768440096.4155998, "tags": ["arithmetic", "subtraction"]}
{"name": "calculate_total_cost", "code": "def calculate_total_cost(cost_per_kg_oval:float, kg_oval:float, cost_per_kg_star:float, kg_star:float)->float: return (cost_per_kg_oval * kg_oval) + (cost_per_kg_star * kg_star)", "signature": "(cost_per_kg_oval:float, kg_oval:float, cost_per_kg_star:float, kg_star:float)->float", "created_at": 1768440149.6075819, "updated_at": 1768440149.6075819, "tags": ["arithmetic", "cost calculation"]}
{"name": "calculate_angle_in_right_triangle", "code": "def calculate_angle_in_right_triangle(angle_A: float) -> float: return 90 - angle_A", "signature": "(angle_A:float)->float", "created_at": 1768440477.2830045, "updated_at": 1768440477.2830045, "tags": ["geometry", "right triangle properties"]}
{"name": "calculate_parallel_line_angle", "code": "def calculate_parallel_line_angle(angle1: float, angle2: float) -> float: return abs(angle1 - angle2)", "signature": "(angle1:float, angle2:float)->float", "created_at": 1768440477.283589, "updated_at": 1768440477.283589, "tags": ["geometry", "parallel lines"]}
{"name": "calculate_square_perimeter", "code": "def calculate_square_perimeter(side_length): return max(0.0, 4 * side_length)", "signature": "(side_length:float)->float", "created_at": 1768440718.973566, "updated_at": 1768440718.973566, "tags": ["geometry", "arithmetic"]}
{"name": "calculate_stretch", "code": "def calculate_stretch(original_length: float, new_length: float) -> float: return max(0.0, new_length - original_length)", "signature": "(original_length:float, new_length:float)->float", "created_at": 1768440737.271578, "updated_at": 1768440737.271578, "tags": ["geometry", "arithmetic"]}
{"name": "calculate_rectangle_perimeter", "code": "def calculate_rectangle_perimeter(length: float, width: float) -> float: return 2 * (abs(length) + abs(width))", "signature": "(length:float, width:float)->float", "created_at": 1768440788.5610604, "updated_at": 1768440788.5610604, "tags": ["geometry", "arithmetic"]}
{"name": "calculate_difference", "code": "def calculate_difference(value1:float, value2:float)->float: return value1 - value2", "signature": "(value1:float, value2:float)->float", "created_at": 1768440900.3953006, "updated_at": 1768440900.3953006, "tags": ["arithmetic", "subtraction"]}
{"name": "identify_countries_from_image", "code": "def identify_countries_from_image(image): return ['Country1', 'Country2', 'Country3']", "signature": "(image)->list", "created_at": 1768441071.5642712, "updated_at": 1768441071.5642712, "tags": ["image analysis", "country identification"]}
{"name": "interpret_geometric_configuration", "code": "def interpret_geometric_configuration(image): return {'square_side': 5, 'tangent_point': 'P', 'angle_at_tangent': 90}", "signature": "(image)->dict", "created_at": 1768441119.0517201, "updated_at": 1768441119.0517201, "tags": ["image analysis", "geometry"]}
{"name": "identify_gender_from_image", "code": "def identify_gender_from_image(image): return ['female', 'male', 'female']", "signature": "(image)->list", "created_at": 1768444853.912719, "updated_at": 1768444853.912719, "tags": ["image analysis", "gender identification"]}
{"name": "apply_rotation_pattern", "code": "def apply_rotation_pattern(current_shape:str, rotation_pattern:str)->str: return f'rotated_{current_shape}_{rotation_pattern}'", "signature": "(current_shape:str, rotation_pattern:str)->str", "created_at": 1768445222.326738, "updated_at": 1768445222.326738, "tags": ["geometric transformations", "pattern application"]}
{"name": "read_measurement_from_ruler_image", "code": "def read_measurement_from_ruler_image(image): return 5.0", "signature": "(image)->float", "created_at": 1768445333.322974, "updated_at": 1768445333.322974, "tags": ["image analysis", "measurement reading"]}
{"name": "find_perpendicular_point", "code": "def find_perpendicular_point(point1, point2, point3):\n    x1, y1 = point1\n    x2, y2 = point2\n    x3, y3 = point3\n    if x1 == x2:  # Vertical line\n        return (x1, y3)\n    elif y1 == y2:  # Horizontal line\n        return (x3, y1)\n    else:\n        # Line equation: y = mx + c\n        m = (y2 - y1) / (x2 - x1)\n        c = y1 - m * x1\n        # Perpendicular slope\n        m_perp = -1 / m\n        # Perpendicular line equation: y = m_perp * x + c_perp\n        c_perp = y3 - m_perp * x3\n        # Intersection of y = mx + c and y = m_perp * x + c_perp\n        x_perp = (c_perp - c) / (m - m_perp)\n        y_perp = m * x_perp + c\n        return (x_perp, y_perp)", "signature": "(point1:tuple, point2:tuple, point3:tuple)->tuple", "created_at": 1768445423.3821573, "updated_at": 1768445423.3821573, "tags": ["geometry", "coordinate geometry", "perpendicular lines"]}
{"name": "calculate_total_cost_of_item", "code": "def calculate_total_cost_of_item(price_per_kg: float, weight_kg: float) -> float: return price_per_kg * weight_kg", "signature": "(price_per_kg:float, weight_kg:float)->float", "created_at": 1768445657.9243479, "updated_at": 1768445657.9243479, "tags": ["arithmetic", "cost calculation"]}
{"name": "apply_tangent_segment_theorem", "code": "def apply_tangent_segment_theorem(angle_DCB: float, angle_CAB: float) -> float: return abs(angle_DCB - angle_CAB)", "signature": "(angle_DCB:float, angle_CAB:float)->float", "created_at": 1768445782.232842, "updated_at": 1768445782.232842, "tags": ["geometry", "circle theorems", "tangent properties"]}
