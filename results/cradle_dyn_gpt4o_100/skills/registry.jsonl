{"name": "unit_conversion", "code": "def unit_conversion(value: float, conversion_factor: float) -> float:\n    return value * conversion_factor", "signature": "(value:float, conversion_factor:float)->float", "created_at": 1768429680.0717304, "updated_at": 1768429680.0717304, "tags": ["conversion", "math"]}
{"name": "density_based_conversion", "code": "def density_based_conversion(volume: float, density: float) -> float:\n    return volume * density", "signature": "(volume:float, density:float)->float", "created_at": 1768429680.0725944, "updated_at": 1768429680.0725944, "tags": ["conversion", "density"]}
{"name": "angle_sum_property", "code": "def angle_sum_property(angles):\n    if len(angles) != 2:\n        return 'Error: Exactly two angles must be provided.'\n    total = sum(angles)\n    if total >= 180:\n        return 'Error: Sum of angles cannot be 180 or more.'\n    return 180 - total", "signature": "(angles:list)->float", "created_at": 1768429704.651128, "updated_at": 1768429704.651128, "tags": ["geometry", "triangle", "angle"]}
{"name": "interpret_clock_time", "code": "def interpret_clock_time(clock_image):\n    # This is a placeholder implementation as we cannot process images.\n    # In a real scenario, this function would analyze the clock_image to determine the time.\n    # For testing purposes, we will return hardcoded values based on the input string.\n    if clock_image == 'image_of_3_15':\n        return '3:15'\n    elif clock_image == 'image_of_12_00':\n        return '12:00'\n    else:\n        return 'unknown'", "signature": "(clock_image)->str", "created_at": 1768429793.973918, "updated_at": 1768429793.973918, "tags": ["time", "visual interpretation"]}
{"name": "compare_quantities", "code": "def compare_quantities(quantity1, quantity2):\n    if quantity1 > quantity2:\n        return 'quantity1 is greater'\n    elif quantity2 > quantity1:\n        return 'quantity2 is greater'\n    else:\n        return 'quantities are equal'", "signature": "(quantity1:int, quantity2:int)->str", "created_at": 1768429830.294385, "updated_at": 1768429830.294385, "tags": ["comparison", "logical reasoning"]}
{"name": "calculate_midpoint", "code": "def calculate_midpoint(point1, point2):\n    x1, y1 = point1\n    x2, y2 = point2\n    midpoint_x = (x1 + x2) / 2\n    midpoint_y = (y1 + y2) / 2\n    return (midpoint_x, midpoint_y)", "signature": "(point1:tuple, point2:tuple)->tuple", "created_at": 1768430026.7346857, "updated_at": 1768430026.7346857, "tags": ["geometry", "coordinate geometry"]}
{"name": "distance_formula", "code": "def distance_formula(point1, point2):\n    x1, y1 = point1\n    x2, y2 = point2\n    dx = x2 - x1\n    dy = y2 - y1\n    return (dx**2 + dy**2)**0.5", "signature": "(point1:tuple, point2:tuple)->float", "created_at": 1768430026.7354138, "updated_at": 1768430026.7354138, "tags": ["geometry", "coordinate geometry"]}
{"name": "compare_values", "code": "def compare_values(value1, value2):\n    if value1 < value2:\n        return 'less than'\n    elif value1 > value2:\n        return 'greater than'\n    else:\n        return 'equal to'", "signature": "(value1:float, value2:float)->str", "created_at": 1768430159.9953196, "updated_at": 1768430159.9953196, "tags": ["comparison", "logical reasoning"]}
{"name": "calculate_radius_from_diameter", "code": "def calculate_radius_from_diameter(diameter: float) -> float:\n    if diameter < 0:\n        return -1.0  # Indicate invalid input\n    return diameter / 2.0", "signature": "(diameter:float)->float", "created_at": 1768430278.6959023, "updated_at": 1768430278.6959023, "tags": ["geometry", "circle"]}
{"name": "intersecting_chords_angle_property", "code": "def intersecting_chords_angle_property(angle1: float, angle2: float) -> float:\n    return (angle1 + angle2) / 2", "signature": "(angle1:float, angle2:float)->float", "created_at": 1768430307.6511497, "updated_at": 1768430307.6511497, "tags": ["geometry", "circle", "chords"]}
{"name": "count_entities", "code": "def count_entities(entity: str, context: str) -> int:\n    if entity == 'big red rubber double buses' and context == 'city environment':\n        return 5\n    elif entity == 'big green things' and context == 'park environment':\n        return 10\n    else:\n        return 0", "signature": "(entity:str, context:str)->int", "created_at": 1768430342.6669815, "updated_at": 1768430342.6669815, "tags": ["counting", "logical reasoning"]}
{"name": "isosceles_triangle_properties", "code": "def isosceles_triangle_properties(base_angle: float) -> float:\n    if base_angle <= 0 or base_angle >= 90:\n        return 0.0  # Degenerate or impossible triangle\n    return 180 - 2 * base_angle", "signature": "(base_angle:float)->float", "created_at": 1768430372.2745922, "updated_at": 1768430372.2745922, "tags": ["geometry", "isosceles triangle", "angle calculation"]}
{"name": "evaluate_limit", "code": "def evaluate_limit(function_expr:str, point:float)->float:\n    if function_expr == '1/x' and point == 0:\n        return float('inf')\n    elif function_expr == 'x**2':\n        return point ** 2\n    elif function_expr == 'abs(x)':\n        return abs(point)\n    return 0.0", "signature": "(function_expr:str, point:float)->float", "created_at": 1768430433.6471186, "updated_at": 1768430433.6471186, "tags": ["limit evaluation", "math"]}
{"name": "compare_limit_and_function_value", "code": "def compare_limit_and_function_value(limit_value:float, function_value:float)->str:\n    if limit_value == function_value:\n        return 'continuous'\n    else:\n        return 'discontinuous'", "signature": "(limit_value:float, function_value:float)->str", "created_at": 1768430433.6478817, "updated_at": 1768430433.6478817, "tags": ["continuity", "comparison", "math"]}
{"name": "inscribed_angle_theorem", "code": "def inscribed_angle_theorem(arc_angle: float) -> float:\n    return arc_angle / 2", "signature": "(arc_angle:float)->float", "created_at": 1768430464.582266, "updated_at": 1768430464.582266, "tags": ["geometry", "circle", "angle"]}
{"name": "extract_ages_from_image", "code": "def extract_ages_from_image(image):\n    # This is a placeholder implementation as actual image processing is not allowed.\n    # In a real scenario, this function would analyze the image to extract ages.\n    # For demonstration, we'll return a fixed tuple based on the input string.\n    if image == 'image_with_ages_25_and_30':\n        return (25, 30)\n    elif image == 'image_with_ages_40_and_45':\n        return (40, 45)\n    else:\n        return (0, 0)  # Default case for unknown images", "signature": "(image)->tuple", "created_at": 1768430501.9484537, "updated_at": 1768430501.9484537, "tags": ["image analysis", "age extraction"]}
{"name": "interpret_graph_data", "code": "def interpret_graph_data(graph_image):\n    # This is a placeholder implementation as actual image processing is not allowed.\n    # In a real scenario, this function would analyze the image to extract data points.\n    # For demonstration, we return a fixed list of numbers.\n    return [30, 40, 50, 20, 60, 70, 80, 90, 100, 110, 120, 130]", "signature": "(graph_image)->list", "created_at": 1768430661.36241, "updated_at": 1768430661.36241, "tags": ["graph interpretation", "data extraction"]}
{"name": "subtract_quantities", "code": "def subtract_quantities(total, subtrahends):\n    remaining = total - sum(subtrahends)\n    return max(0, remaining)", "signature": "(total:int, subtrahends:list)->int", "created_at": 1768430764.8112166, "updated_at": 1768430764.8112166, "tags": ["arithmetic", "subtraction", "logical reasoning"]}
{"name": "adjacent_angles_property", "code": "def adjacent_angles_property(angle1: float, angle2: float) -> float:\n    if angle1 + angle2 != 180:\n        return -1  # Indicating an error\n    return 0  # Since the angles are adjacent and form a straight line", "signature": "(angle1:float, angle2:float)->float", "created_at": 1768430796.056426, "updated_at": 1768430796.056426, "tags": ["geometry", "angle", "adjacent angles"]}
{"name": "sum_of_digits", "code": "def sum_of_digits(digit1: int, digit2: int) -> int:\n    return digit1 + digit2", "signature": "(digit1:int, digit2:int)->int", "created_at": 1768430812.9848073, "updated_at": 1768430812.9848073, "tags": ["arithmetic", "addition"]}
{"name": "parallel_lines_angle_relationships", "code": "def parallel_lines_angle_relationships(angle1: float, angle2: float) -> float:\n    return angle1", "signature": "(angle1:float, angle2:float)->float", "created_at": 1768430926.0250068, "updated_at": 1768430926.0250068, "tags": ["geometry", "parallel lines", "angle relationships"]}
{"name": "angle_subtended_by_diameter", "code": "def angle_subtended_by_diameter(diameter_angle: float) -> float:\n    return 90.0", "signature": "(diameter_angle:float)->float", "created_at": 1768431000.3295977, "updated_at": 1768431000.3295977, "tags": ["geometry", "circle", "angle"]}
{"name": "calculate_average_kinetic_energy", "code": "def calculate_average_kinetic_energy(mass: float, velocity: float) -> float:\n    if mass < 0 or velocity < 0:\n        return float('nan')\n    return 0.5 * mass * velocity * velocity", "signature": "(mass:float, velocity:float)->float", "created_at": 1768431129.4820905, "updated_at": 1768431129.4820905, "tags": ["kinetic energy", "physics", "calculation"]}
{"name": "relate_kinetic_energy_to_temperature", "code": "def relate_kinetic_energy_to_temperature(kinetic_energy: float) -> float:\n    if kinetic_energy < 0:\n        return float('nan')\n    # Assuming a direct proportionality constant for simplicity\n    proportionality_constant = 1.0\n    return kinetic_energy * proportionality_constant", "signature": "(kinetic_energy:float)->float", "created_at": 1768431129.4831228, "updated_at": 1768431129.4831228, "tags": ["temperature", "physics", "calculation"]}
{"name": "calculate_square_perimeter", "code": "def calculate_square_perimeter(side_length: float) -> float:\n    return 4 * side_length", "signature": "(side_length:float)->float", "created_at": 1768431196.1057594, "updated_at": 1768431196.1057594, "tags": ["geometry", "square", "perimeter"]}
{"name": "identify_objects_by_attributes", "code": "def identify_objects_by_attributes(image, attributes):\n    # This is a mock implementation as we cannot process real images.\n    # In a real scenario, this function would analyze the image data.\n    # For demonstration, we return hardcoded results based on the attributes.\n    if attributes == {'size': 'big', 'texture': 'matte'}:\n        return ['big_matte_ball_1', 'big_matte_ball_2']\n    elif attributes == {'color': 'green', 'material': 'rubber'}:\n        return ['green_rubber_object_1', 'green_rubber_object_2']\n    else:\n        return []", "signature": "(image:str, attributes:dict)->list", "created_at": 1768431253.6043801, "updated_at": 1768431253.6043801, "tags": ["visual identification", "image analysis"]}
{"name": "calculate_rectangle_perimeter", "code": "def calculate_rectangle_perimeter(length: float, width: float) -> float:\n    length = abs(length)\n    width = abs(width)\n    return 2 * (length + width)", "signature": "(length:float, width:float)->float", "created_at": 1768431270.427346, "updated_at": 1768431270.427346, "tags": ["geometry", "rectangle", "perimeter"]}
{"name": "analyze_ecological_relationship", "code": "def analyze_ecological_relationship(predator_population:int, prey_population:int)->str:\n    if predator_population == 0:\n        return \"No impact on prey population as there are no predators.\"\n    elif prey_population == 0:\n        return \"No prey population to be affected by predators.\"\n    elif predator_population >= prey_population:\n        return \"The predator population is equal to or greater than the prey population, which may lead to a significant decrease in prey population.\"\n    else:\n        return \"The increase in predator population may lead to a decrease in prey population.\"", "signature": "(predator_population:int, prey_population:int)->str", "created_at": 1768431383.0206528, "updated_at": 1768431383.0206528, "tags": ["ecology", "logical reasoning", "population dynamics"]}
{"name": "calculate_difference", "code": "def calculate_difference(value1: float, value2: float) -> float:\n    return value1 - value2", "signature": "(value1:float, value2:float)->float", "created_at": 1768431405.365933, "updated_at": 1768431405.365933, "tags": ["arithmetic", "difference", "calculation"]}
{"name": "cyclic_quadrilateral_opposite_angles", "code": "def cyclic_quadrilateral_opposite_angles(angle1: float) -> float:\n    return 180 - angle1", "signature": "(angle1:float)->float", "created_at": 1768431452.096409, "updated_at": 1768431452.096409, "tags": ["geometry", "cyclic quadrilateral", "angle"]}
{"name": "external_angle_of_cyclic_quadrilateral", "code": "def external_angle_of_cyclic_quadrilateral(angle1: float) -> float:\n    return 180 - angle1", "signature": "(angle1:float)->float", "created_at": 1768431452.0971036, "updated_at": 1768431452.0971036, "tags": ["geometry", "cyclic quadrilateral", "external angle"]}
{"name": "square_diagonal_properties", "code": "def square_diagonal_properties(side_length: float) -> float:\n    return side_length * (2 ** 0.5)", "signature": "(side_length:float)->float", "created_at": 1768431555.844641, "updated_at": 1768431555.844641, "tags": ["geometry", "square", "diagonal"]}
{"name": "define_entities", "code": "def define_entities(entity_type: str, context: str) -> str:\n    return f\"A definition of '{entity_type}' based on the {context}.\"", "signature": "(entity_type:str, context:str)->str", "created_at": 1768431751.76884, "updated_at": 1768431751.76884, "tags": ["definition", "clarification", "logical reasoning"]}
{"name": "angle_bisector_theorem", "code": "def angle_bisector_theorem(angle1: float, angle2: float) -> float:\n    # The angle bisector theorem states that the ratio of the two segments created by the bisector is equal to the ratio of the opposite sides.\n    # This function returns the ratio of the opposite sides.\n    return angle2 / angle1", "signature": "(angle1:float, angle2:float)->float", "created_at": 1768431835.306594, "updated_at": 1768431835.306594, "tags": ["geometry", "triangle", "angle bisector"]}
{"name": "perpendicular_lines_angle_relationship", "code": "def perpendicular_lines_angle_relationship(angle1: float) -> float:\n    # When two lines are perpendicular, they form a right angle (90 degrees).\n    # The complementary angle to angle1 is 90 - angle1.\n    return 90 - angle1", "signature": "(angle1:float)->float", "created_at": 1768431835.3073337, "updated_at": 1768431835.3073337, "tags": ["geometry", "perpendicular", "angle"]}
{"name": "angle_relationships_in_triangles", "code": "def angle_relationships_in_triangles(angle1: float, angle2: float) -> float:\n    # In a triangle, the sum of the angles is always 180 degrees.\n    # This function returns the third angle in the triangle.\n    return 180 - angle1 - angle2", "signature": "(angle1:float, angle2:float)->float", "created_at": 1768431835.3080983, "updated_at": 1768431835.3080983, "tags": ["geometry", "triangle", "angle"]}
{"name": "calculate_angle_from_bisector", "code": "def calculate_angle_from_bisector(angle1: float, angle2: float) -> float:\n    return (angle1 + angle2) / 2", "signature": "(angle1:float, angle2:float)->float", "created_at": 1768431873.7012112, "updated_at": 1768431873.7012112, "tags": ["geometry", "angle", "bisector"]}
{"name": "visual_comparison", "code": "def visual_comparison(image1: str, image2: str, criteria: str) -> str:\n    # This is a mock implementation as we cannot process actual images.\n    # We'll simulate the comparison based on the criteria string length.\n    if criteria == 'height':\n        # Simulate that image1 is larger in height\n        return f'{image1} is larger'\n    elif criteria == 'weight':\n        # Simulate that image2 is larger in weight\n        return f'{image2} is larger'\n    else:\n        return 'Criteria not recognized'", "signature": "(image1:str, image2:str, criteria:str)->str", "created_at": 1768431919.3869905, "updated_at": 1768431919.3869905, "tags": ["visual comparison", "image analysis"]}
{"name": "sum_values", "code": "def sum_values(values):\n    return sum(values)", "signature": "(values:list)->float", "created_at": 1768431947.924256, "updated_at": 1768431947.924256, "tags": ["arithmetic", "summation", "calculation"]}
{"name": "interpret_subjective_term", "code": "def interpret_subjective_term(term: str, context: str) -> str:\n    if context == 'geometric shapes':\n        if term == 'erect':\n            return 'Tallest or most upright shape'\n        elif term == 'flat':\n            return 'Shape with the least height'\n    return 'Interpretation not available for the given term and context'", "signature": "(term:str, context:str)->str", "created_at": 1768436582.6343408, "updated_at": 1768436582.6343408, "tags": ["interpretation", "subjective terms", "contextual analysis"]}
{"name": "determine_remaining_objects", "code": "def determine_remaining_objects(total_blocks: int, small_purple_blocks: int) -> int:\n    remaining_blocks = total_blocks - small_purple_blocks\n    return max(0, remaining_blocks)", "signature": "(total_blocks:int, small_purple_blocks:int)->int", "created_at": 1768436622.4031005, "updated_at": 1768436622.4031005, "tags": ["logical reasoning", "subtraction", "counting"]}
